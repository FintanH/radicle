#!/usr/bin/env radicle

;; TODO:
;;   - docstrings
;;   - move arg-parsing stuff into a library (and factor it out of rad-issues too)
;;   - pretty print prs
;;   - don't use make-chain-ref when we don't need loading
;;   - deal with multiple patches properly (e.g. in pretty-pr)
;;   - make and use cmd-2 pattern
;;   - handle parsing numbers in cmd-parsing/validation logic
;;   - be graceful about checkouts failing
;;   - should we be using "git diff", rather than squashing and then git format-patch?


(load! "rad/prelude.rad")
(load! "rad/monadic/git.rad")
(load! "rad/prelude/io-utils.rad")
(import prelude/validation :as 'validation)

(def help "rad-git")

(def base-name "http://localhost:8000/chains/")

(def name-base "http://machines.radicle.xyz/chains/names")

(def make-name
  (fn [chain]
    (if (eq? (take 7 chain) "http://")
        chain
        (string-append base-name chain))))

(def make-chain-ref
  (fn [chain]
    (ref (chain/load-chain! (make-name chain)))))

(def get-patch!
  (fn [diff-range]
    (string/unlines (process-with-stdout! "git" ["diff" diff-range] ""))))

(def get-base-commit!
  (fn []
    (string/unlines (process-with-stdout! "git" ["rev-parse" "master"] ""))))

(def apply-patch!
  "Given a patch, apply it to the current branch"
  (fn [patch]
    (process! "git" ["apply" "-"] patch)))

(def new-pr!
  (fn [chain diff-range]
    (def patch (get-patch! diff-range))
    (def base (get-base-commit!))
    (def pr-template
";; PR template. An empty or invalid value will abort.
{:title       \"Pick a title\"
 :description \"Pick a body\"
}
")
    (def pr (<> (read (edit-in-editor! pr-template)) {:patch [patch] :base-commit base}))
    (simple-create-pr! (make-chain-ref chain) pr)))

(def pretty-pr
  (fn [pr]
    (string-append
      (lookup :title pr)
      "\n"
      (lookup :description pr)
      "\n"
      (head (lookup :patch pr)))))

(def checkout-pr!
  "Creates a new branch pr/<PR-number> based on the PR, and switches to it."
  (fn [chain pr-no]
    (def chain-ref (make-chain-ref chain))
    (def pr
      (match (lookup pr-no (list-prs chain-ref))
        'the-pr  the-pr
        :nothing (do
                   (put-str! "No such PR")
                   (exit! 1))))
   ;; (process! "git" ["checkout" (lookup :base-commit pr)] "")
   ;; (process! "git" ["checkout" "-b" (string-append "pr/" (show pr-no))] "")
    (put-str! (head (lookup :patch pr)))
;;    (apply-patch! (head (lookup :patch pr)))))
    ))

(def list-items
  "Lists the recent items and uses an editor to add a relevant comment."
  (fn [chain last-seen]

    (def chain-ref (make-chain-ref chain))
    (load! "rad/monadic/names.rad")
    (def names (ref (chain/load-chain! name-base)))
    (def add-username
      (fn [d]
        (def n (match (lookup-key names (lookup :author d))
                          :nothing "???"
                          'name    name))
        (insert :username n d)))

    (def add-username-pr
      (fn [i]
        (add-username
         (insert :comments (map add-username (lookup :comments i)) i))))

    (def mk-key
      (fn [v]
        (match v
               (/as 'a {:activity :new-pr
                        :pr    {:number 'n
                                   :title 'tit}})
               [(string-append "[new] PR " (show n) " - " tit) a]
               (/as 'a {:activity :new-comments
                        :pr    {:number 'n
                                   :title 'tit}})
               [(string-append "[new comments] PR " (show n) " - " tit) a]
               (/as 'i {:pr {:number 'n :title 'tit}})
               [(string-append "PR " (show n) " - " tit) i])))

    (def items
      (map mk-key
           (match last-seen
             (/just 't) (recent-activity chain-ref t)
             _          (map (fn [i] {:pr i})
                             (reverse (values (list-prs chain-ref)))))))

    (put-str! (head (lookup :patch (lookup :pr (nth 1 (head items))))))
    (def items-dict (dict-from-seq items))
    (if (empty-seq? items)
      (put-str! "No recent items!")
      (match (fzf-select-with-preview!
               (map first items)
               (fn [s] (pretty-pr (add-username-pr (lookup :pr (lookup s items-dict))))))
             (/just 's)
             (do (def selected (lookup s items-dict))
                 (def pr-number (match selected {:pr {:number 'n}} n))
                 (def pretty-item
                   (pretty-pr
                     (add-username-issue
                      (lookup :issue selected))))
                 (def edited-item (edit-in-editor! pretty-item))
                 (put-str! "Item was not updated.")
             _ (put-str! "No selection made."))))))

(def new-pr-chain!
  "Create a new PR chain with the given URL"
  (fn [name]
    (chain/send-prelude! name)
    (send-code! name "rad/monadic/git-remote.rad")))

;; Command-line parsing


(def cmd-parse-failure
  (fn [error]
    (put-str! error)
    (put-str! help)
    (exit! 1)
  ))

(def /cmd-1
  (fn [cmd cmd-args-pat]
    ((validation/type :string) cmd)
    ((validation/type :atom) cmd-args-pat)
    (fn [value]
      (match value
        [cmd 'cmd-args] (match-pat cmd-args-pat cmd-args)
        [cmd] (cmd-parse-failure (string-append "Missing argument \"" (show cmd-args-pat) "\" for command \"" cmd "\""))
        (/cons cmd _) (cmd-parse-failure (string-append "Too many arguments for command \"" cmd "\""))
        _ :nothing)
    )))

(def /cmd-0
  (fn [cmd]
    ((validation/type :string) cmd)
    (fn [value]
      (match value
        [cmd] [:just {}]
        (/cons cmd _) (cmd-parse-failure (string-append "Too many arguments for command \"" cmd "\""))
        _ :nothing)
    )))


(def args (get-args!))
(match args
  ["propose" 'chain-name 'range] (new-pr! (make-name chain-name) range)
  ["checkout" 'chain-name 'pr-no] (checkout-pr! chain-name (read pr-no))
  (/cmd-1 "create-chain" 'chain-name) (new-pr-chain! (make-name chain-name))
  (/cmd-1 "list" 'chain-name) (list-items (make-name chain-name) :nothing)
  ["help"] (put-str! help)
  ["-h"] (put-str! help)
  ["--help"] (put-str! help)
  (/cons 'cmd _) (cmd-parse-failure (string-append "Unknown command: " cmd))
  [] (put-str! help))
