#!/usr/bin/env radicle

(load! "rad/prelude.rad")
(load! "rad/monadic/git.rad")
(load! "rad/prelude/io-utils.rad")

(def base-name "http://machines.radicle.xyz/chains/")

(def name-base "http://machines.radicle.xyz/chains/names")

(def make-name
  (fn [chain]
    (if (eq? (take 7 chain) "http://")
        chain
        (string-append base-name chain))))

(def make-chain-ref
  (fn [chain]
    (ref (chain/load-chain! (make-name chain)))))

(def get-patch!
  (fn []
    (string/unlines (process-with-stdout! "git" ["format-patch" "master..HEAD" "--stdout"] ""))))

(def get-base-commit!
  (fn []
    (string/unlines (process-with-stdout! "git" ["rev-parse" "master"] ""))))

(def apply-patch!
  "Given a patch, apply it to the current branch"
  (fn [patch]
    (process! "git" ["apply" "-"] patch)))

(def new-pr!
  (fn [chain]
    (def patch (get-patch!))
    (def base (get-base-commit!))
    (def pr-template
";; PR template. An empty or invalid value will abort.
{:title       \"Pick a title\"
 :description \"Pick a body\"
}
")
    (def pr (<> (read (edit-in-editor! pr-template)) {:patch [patch] :base-commit base}))
    (simple-create-pr! chain pr)))

(def pretty-pr show)

(def checkout-pr!
  "Creates a new branch pr/<PR-number> based on the PR, and switches to it."
  (fn [chain pr-no]
    (def chain-ref (make-chain-ref chain))
    (def patch
      (match (lookup pr-no (read-ref chain-ref))
        'pr      pr
        :nothing (do
                   (put-str! "No such PR")
                   (exit! 1))))
    (process! "git" ["checkout" "-b" (string-append "pr/" (show pr-no))] "")
    (apply-patch! patch)))

(def list-items
  "Lists the recent items and uses an editor to add a relevant comment."
  (fn [chain last-seen]

    (def chain-ref (make-chain-ref chain))
    (load! "rad/monadic/names.rad")
    (def names (ref (chain/load-chain! name-base)))
    (def add-username
      (fn [d]
        (def n (match (lookup-key names (lookup :author d))
                          :nothing "???"
                          'name    name))
        (insert :username n d)))

    (def add-username-pr
      (fn [i]
        (add-username
         (insert :comments (map add-username (lookup :comments i)) i))))

    (def mk-key
      (fn [v]
        (match v
               (/as 'a {:activity :new-pr
                        :pr    {:number 'n
                                   :title 'tit}})
               [(string-append "[new] PR " (show n) " - " tit) a]
               (/as 'a {:activity :new-comments
                        :pr    {:number 'n
                                   :title 'tit}})
               [(string-append "[new comments] PR " (show n) " - " tit) a]
               (/as 'i {:pr {:number 'n :title 'tit}})
               [(string-append "PR " (show n) " - " tit) i])))

    (def items
      (map mk-key
           (match last-seen
             (/just 't) (recent-activity chain-ref t)
             _          (map (fn [i] {:pr i})
                             (reverse (values (list-prs chain-ref)))))))

    (def items-dict (dict-from-seq items))
    (if (empty-seq? items)
      (put-str! "No recent items!")
      (match (fzf-select-with-preview!
               (map first items)
               (fn [s] (pretty-pr (add-username-pr (lookup :pr (lookup s items-dict))))))
             (/just 's)
             (do (def selected (lookup s items-dict))
                 (def pr-number (match selected {:pr {:number 'n}} n))
                 (def pretty-item
                   (pretty-pr
                     (add-username-issue
                      (lookup :issue selected))))
                 (def edited-item (edit-in-editor! pretty-item))
                 (put-str! "Item was not updated.")
             _ (put-str! "No selection made."))))))

(def new-pr-chain!
  "Create a new PR chain with the given URL"
  (fn [url]
    (chain/send-prelude! chain)
    (send-code! url "rad/monadic/git-remote.rad")))
(def chain-name "http://localhost:8000/chains/foo")
(def chain (ref (chain/new-chain chain-name)))
(fetch! chain)
(list-items chain-name :nothing)
