(load! "rad/prelude.rad")

(import prelude/strings :unqualified)
(import prelude/list :unqualified)
(import prelude/machine :unqualified)

(def repeat
  "A list with `item` repeated `n` times."
  (fn [n item]
    (map (fn [_] item) (range 0 n))))

(def slide
  (fn [t body]
    (def n (string-length t))
    (def tit (string-append t "\n" (intercalate "" (repeat (- n 1) "-"))))
    (string-append tit "\n\n" body)))

(def i (ref 0))

(def intro
  [
   (slide
    "The promise of the web"
    "Just computers, but connected")

   (slide
    "The reality of the web"
    "Not all computers are equal")

   (slide
    "Consequently:"
    "Everything tends to centralize")

   (slide
    "Counterefforts:"
    "- (PoW) Blockchains")

   (slide
    "Counterefforts:"
    "- (PoW) Blockchains
- P2P (Dat, SSB, IPFS)"
    )

   (slide
    "P2P:"
    "So far, mostly dumb data"
    )
   (slide
    "P2P:"
    "The feed items are inputs to a state machine"
    )
   ])


(def rad-lang-props
  [(slide
    "State machine"
    "
           f
  (I,S) ------> S

Running the state machine over the feed
of inputs gives us the semantics.")

   (slide
    "State machine"
    "
feed   tx
-----  --------------
 1     (x,y) => x + y
 2
 1
 3
 ...

=> 7")

   (slide
    "Morphable?"
    "How can we deal with changing requirements?

 - Feed is the only inputs
 - New semantics are defined by code

=> inputs == code
=> P2P Lisp REPL")

   (slide
    "P2P LISP REPL"
    "(def tx (fn [x y] (+ x y)))
1
2
...

(read-ref state)
=> 7")
   
   "(def tx
  ...
  (if enough-votes?
      (new-semantics!)
      :nope))"

   (slide
    "Deterministic"
    "The evaluation of the feed is the meaning.

=> Evaluation should give the same result for everyone
=> Deterministic programming language")

   (slide
    "Deterministic"
    "(def x 4)
(def y 6)
...

(+ x y)
  => 10

Everyone should get same result!")])

(def structure-on-ipld
  [
  (slide
   "IPFS Blocks"
   "
[ data: (+ x y) ] ===>[ data: (def x 3) ] |====> [ data: (def y 2) ]
[ prev: ========]=|   [ prev: ==========]=|      [ prev: null      ] ")

  (slide
   "IPFS Blocks"
   "
   IPNS pointer
     |
     V
[ data: (+ x y) ] ===>[ data: (def x 3) ] |====> [ data: (def y 2) ]
[ prev: ========]=|   [ prev: ==========]=|      [ prev: null      ] ")
   ])

(def transparent-machines
  [(slide
    "Forking"
    "The big problem with feeds.

Simple consensus:
  All items signed by one key.

But: this means the owner can change semantics..")

   (slide
    "Monitors"
    "P2P network of monitor nodes

These are nodes which check
  - the machine doesn't fork
  - the machine respects radicle semantics")

   (slide
    "Fork-proofs"
    "Two /= signed heads that lead to a common prefix.

Once a fork is detected, a fork proof
is broadcast to all followers

=> The machine is considered dead.")

   "Now machine owners are locked in:

The most they can do is kill their machine."

   (slide
    "Hosting solves Availability"
    "Hosting on laptop: no writes when owner is offline.

But with monitoring there is no risk
in using a highly available host.")]
  )

(def conclusion
  [ (slide
     "Conclusion"
     "")
   
   (slide
    "Examples"
    "- Code collaboration projects
- Structured discussions
- Decision making (voting, etc.)
- Package manager")
                 ])

(def parts
  [["r a d i c l e
-------------

A P2P programming language

  James Haydon
  Julian Arni

  www.radicle.xyz"

    "1. Motivation and vision.
2. Radicle-lang properties.
3. Architecture on IPFS.
4. Transparent machines."

    "1. Motivation and vision."
    ]
   intro
   ["2. Radicle-lang properties."]
   rad-lang-props
   ["3. IPLD structure."]
   structure-on-ipld
   ["4. Transparent machines."]
   transparent-machines
   conclusion
   ])

(def prompts
  (foldr <> [] parts))

(def height 10)
(def clear (fn [] (put-str! (unlines (repeat 50 " ")))))

(def next
  (fn []
    (clear)
    (def it (nth (read-ref i) prompts))
    (def fill (unlines (repeat (- height (length (lines it))) " ")))
    (put-str! it)
    (put-str! "\n------\n")
    (put-str! fill)
    (modify-ref i \(+ 1 ?))))

(def thanks!
(fn []
  (put-str! "Thanks!")))


(clear)
