(import prelude/strings :unqualified)
(import prelude/list :unqualified)
(import prelude/machine :unqualified)

(def repeat
  "A list with `item` repeated `n` times."
  (fn [n item]
    (map (fn [_] item) (range 0 n))))

(def slide
  (fn [t body]
    (def n (string-length t))
    (def tit (string-append t "\n" (intercalate "" (repeat (- n 1) "-"))))
    (string-append tit "\n\n" body)))

(def i (ref 0))

(def intro
  [
   (slide
    "The promise of the web"
    "Just computers, but connected")

   (slide
    "The reality of the web"
    "Not all computers are equal")

   (slide
    "Consequently:"
    "Everything tends to centralize")

   (slide
    "Counterefforts:"
    "- (PoW) Blockchains")

   (slide
    "Counterefforts:"
    "- (PoW) Blockchains
- P2P (Dat, SSB, IPFS)"
    )

   (slide
    "P2P:"
    "So far, mostly dumb data"
    )
   (slide
    "P2P:"
    "The feed items are inputs to a state machine"
    )
   ])


(def rad-lang-props
  [(slide
    "State machine"
    "
         f
(I, S) -----> S

Running the state machine over the feed
of inputs gives us the semantics.")

   (slide
    "Morphable state-machine?"
    "Machines are for ever, but requirements always change..

 - The machine is fully determined by its inputs.
 - Semantics is defined by code.
=> inputs = data = code
=> it's just a P2P Lisp REPL")
   
   "Not only can the semantics change,
the semantics can specify the rules
of how the semantics change:

(def tx
  ...
  (if enough-votes?
      (new-semantics!)
      :nope))"
   
   (slide
    "Deterministic"
    "The feed is not only read it is _evaluated_.

Result is the _meaning_.")

   (slide
    "Deterministic"
    "(def x 4)
(def y 6)
(+ x y)")
   
   (slide
    "Deterministic"
    "Everyone should get the same result.

=> DETERMINISTIC")   ])

(def structure-on-ipld
  [])

(def transparent-machines
  [(slide
    "Forking"
    "The big problem with feeds.

Simple consensus:
  All items signed by one key.

But: this means the owner can change semantics..")

   (slide
    "Monitors"
    "P2P network of monitor nodes

These are nodes which check
  - the machine doesn't fork
  - the machine respects radicle semantics")

   (slide
    "Fork-proofs"
    "Two /= signed heads that lead to a common prefix.

Once a fork is detected, a fork proof
is broadcast to all followers

=> The machine is considered dead.")

   "Now machine owners are locked in:

The most they can do is kill their machine."

   (slide
    "Hosting solves Availability"
    "Hosting on laptop: no writes when owner is offline.

But with monitoring there is no risk
in using a highly available host.")]
  )

(def conclusion [])

(def parts
  [["r a d i c l e
-------------

A P2P programming language

  James Haydon
  Julian Arni

  www.radicle.xyz"

    "1. Motivation and vision.
2. Radicle-lang properties.
3. Architecture on IPFS.
4. Transparent machines."

    "1. Motivation and vision."
    ]
   intro
   ["2. Radicle-lang properties."]
   rad-lang-props
   structure-on-ipld
   transparent-machines
   conclusion
   ])

(def prompts
  (foldr <> [] parts))

(def height 10)
(def clear (fn [] (put-str! (unlines (repeat 50 " ")))))

(def next
  (fn []
    (clear)
    (def it (nth (read-ref i) prompts))
    (def fill (unlines (repeat (- height (length (lines it))) " ")))
    (put-str! it)
    (put-str! "\n------\n")
    (put-str! fill)
    (modify-ref i \(+ 1 ?))))

(def thanks!
(fn []
  (put-str! "Thanks!")))


(clear)
