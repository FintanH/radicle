# Chains

By now you've seen some of `radicle`, but we haven't touched upon what makes it
different from other languages.

## The execution context

The most familiar way to think about a program execution is as happening on one
particular machine. *Which* machine that is often matters to understanding how
the program behaves; a program might after all read from a file, for example,
and behave differently based on whether that file exists, and what it's
contents are. But other machines may not have that file, or have one that
differs in some way. 

This aspect of program execution is often a source of headache for developers,
as it leads to hard-to-reproduce or -predict behavior. But--and more
importantly for our purposes--it also means we can't think of programs in the
abstract

In other words, we would like for programs to be *deterministic*. 


## Exploring chains

You can enter an environment that corresponds to a chain:

```
(def x 0) 
x 			   ;; ==> 0
(:enter-chain empty-chain) ;; ==> :ok
(def x 1)
x 			   ;; ==> 1
:quit 			   ;; ==> :ok
x 			   ;; ==> 0
```

As you can see, between entering a chain (with `:enter-chain`) and leaving it
(with `:quit`), all inputs are evaluated in the context of that chain.

(You may be wondering how `(:enter-chain empty-chain)` could possibly be valid, 
as it contains a keyword apparently doing the job of a function application. 
The short answer is that we can define special macro-like operations, of which
we will see more.)
