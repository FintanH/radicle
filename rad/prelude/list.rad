;; List functions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; nil

(def nil "The empty list." (list))

;; empty?

(def empty?
  "True if 'seq' is empty, false otherwise."
  (fn [ls] (or (eq? ls nil) (eq? ls []))))

(:test "empty"
  [ (empty? (list 2)) ==> #f ]
  [ (empty? [2]) ==> #f ]
  [ (empty? []) ==> #t ]
)

;; reverse

(def reverse
  "Returns the reversed 'list'."
  (fn [ls]
    (def go (Y2 (fn [go]
      (fn [acc new]
        (if (empty? new)
            acc
            (go (cons (head new) acc) (tail new)))))))
    (go (list) ls)))

(:test "reverse"
  [ (reverse (list 1 2 3)) ==> (3 2 1) ]
)

;; range

(def range
  "Returns a list with all integers from 'start' to 'end', inclusive."
  (Y2 (fn [range] (fn [from to]
    (if (eq? from to)
        (list to)
        (cons from (range (+ 1 from) to)))))))

(:test "range"
  [ (range 1 5) ==> (1 2 3 4 5) ]
)

;; concat

(def concat
  "Concatenates 'list1' and 'list2'."
  (fn [list1 list2]
    (foldr (fn [a b] (cons a b)) list2 list1)))

(:test "concat"
  [ (concat '(1 2 3) '(4 5 6)) ==> (1 2 3 4 5 6) ]
)

;; filter

(def filter
  "Returns 'list' with only the elements that satisfy 'filter-cond'."
    (Y2 (fn [filter] (fn [pred ls]
      (if (empty? ls)
          ls
      (if (pred (head ls))
          (cons (head ls) (filter pred (tail ls)))
          (filter pred (tail ls))))))))

(:test "filter"
  [ (filter (fn [x] (< x 10)) (list 3 10 11))
     ==> (3) ]
)

(def list-with-head
  "Given a value `x`, and two functions `f` and `g`, checks if `x` is a list with a
  head. If so applies `f` to the head, otherwise calls `g` with no args."
  (fn [x f g]
    (if (list? x)
      (if (> (length x) 0)
        (f (head x))
        (g))
      (g))))
