{:module 'prelude/machine-remote
 :doc "Functions for writing remote RSMs"
 :exports '[lock-machine]}

(import prelude/ref '[modify-ref] :unqualified)
(import prelude/patterns :unqualified)

(def lock-machine
  "Lock the arbitrary transactions of a machine using a validator."
  (fn [validator f]
    (fn [expr _state]
      (match expr
             (/cons 'cmd _) (if (eq? cmd 'update)
                              (do (validator (nth 1 expr))
                                  (lookup :eval (nth 1 expr)))
                              (f expr))
             _ (f expr))
      )))

(:test
 "lock-machine"
 [:setup
  (do
    (machine/install-remote-machine-fake)
    (def id (machine/new-machine!))
    (machine/send-prelude! id)
    (machine/send!
     id
     '[(import prelude/patterns :unqualified)
       (import prelude/ref :unqualified)
       (import prelude/machine-remote '[lock-machine] :unqualified)
       (def counter (ref 0))
       (def inc (ref (fn [] (modify-ref counter (fn [x] (+ x 1))))))
       (def get (fn [] (read-ref counter)))
       (def tx
         (lock-machine
          (fn [x]
            (if (eq? (lookup :pwd x) "secret")
              :ok
              (throw 'validation-failure "nope")))
          (fn [e]
            (match e
                   :inc ((read-ref inc))
                   :get (get)
                   _    (throw 'bad-input "Just :inc!")))))])
    (machine/send! id [:inc :inc])
    (def i (machine/query! id :get))
    (machine/send!
     id
     ['(update
        {:eval (write-ref inc (fn [] (modify-ref counter (fn [x] (+ x 2)))))
         :pwd "secret"})])
    (machine/send! id [:inc :inc])
    (def j (machine/query! id :get))
    (def ok (catch 'validation-failure
                (machine/send!
                 id
                 ['(update
                    {:eval (write-ref inc (fn [] (modify-ref counter (fn [x] (+ x 2)))))
                     :pwd "badsecret"})])
              (fn [ignore_] :ok)))
    )
  ]
 [ i ==> 2 ]
 [ j ==> 6 ]
 [ ok ==> :ok ]
 )
