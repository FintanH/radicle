;; Chains: Functions for dealing with chains.

;; A chain is conceptually:
;;   - A known starting state (i.e. environment, and the assumption that `eval
;;     == base-eval')
;;   - A sequence of inputs.

;; TODO do we want this? then move it
;; (def eval-ref (ref eval))
;; (def eval (fn [expr env] ((read-ref eval-ref) expr env)))


(def empty-chain
  {:state (pure-env)
   :inputs (list)
   :index 0})

(def test-chain 
  (set (... (list (@ :state) (@ :env) (@ 'eval))) (fn [expr env] (list #t env)) empty-chain) )  

;; eval-in-chain

(def eval-in-chain
  (fn [expr chain]
    (def x (eval expr (lookup :state chain)))
    (dict :chain (dict :state (head (tail x))
                       :input (cons expr (lookup :logs chain))
                       :index (+ 1 (lookup :index chain)))
          :result (head x))))

(document 'eval-in-chain
          '(("expr" any) ("chain" chain))
          "Evaluates 'expr' in the 'chain' and returns a dict with the ':result' and the resulting ':chain'.")

(do 
  (def res (eval-in-chain '(+ 3 2) empty-chain))
  (def ~~> (fn [comp expected] (should-be "eval-in-chain" (view comp res) expected)))
  (~~> (@ :result) 5)
  (~~> (.. (@ :chain) (@ :input)) '((+ 3 2)))
  (~~> (.. (@ :chain) (@ :index)) 1))

;; update-chain-with

(def update-chain-with
  (fn [chain remote-chain-id cb-expr cb-res]
    (def new-inputs
      (receive! remote-chain-id (lookup :index chain)))
    (def upd-ch
      (fn [ch expr]
        (def x (eval-in-chain expr ch))
        (cb-expr expr)
        (cb-res (view (@ :result) x))
        (view (@ :chain) x)))
    (foldl upd-ch chain new-inputs)))

(document 'update-chain-with
          '(("chain" chain) ("chain-id" string) ("cb-expr" function) ("cb-res" function))
          "Updates 'chain' according to activity on the remote chain with ID 'chain-id', by pulling down and evaluating new inputs. Accepts two callbacks: 'cb-expr' is applied to the incoming expressions, and 'cb-res' is applied to the resulting values. Usually one uses 'print!' for both of these. If 'chain' is not a past version of the remote chain then the behaviour is unspecified.")

;; set-topmost-st

;; (def set-topmost-st
;;   (fn [new-state]
;;     (def once (fn [x y]
;;       (def first? (ref #t))
;;       (if (read-ref first?) x y))) 
;;     (def  
;;     (write-ref eval-ref 

;; add-quit

(def add-quit
  (fn [old-state new-eval]
    (fn [expr env]
      (if (eq? expr :quit)
          (list :ok old-state)
          (new-eval expr env)))))

;; enter-chain


;; (def test-chain 
;;   (set (.. (@ :state) (@ :env) (@ 'eval)) (fn [expr env] (list #t env)) empty-chain ))  


;; (def enter-chain
;;   (fn [chain]
;;     (def old-eval eval)
;;     (def ch (ref chain))
;;     (add-quit old-eval  
;;     (def ev
;;       (fn [e env]
;;         (print! e)
;;         (if (eq? e :quit)
;;             (do (print! "leaving chain")
;;                 (list :ok old-state))
;;           (do (def x (eval e (read-ref ch)))
;;               (write-ref ch (view (@ :chain) x))
;;               (list (view (@ :result) x) env)))))
;;     (print! "here")
;;     (write-ref eval-ref ev)))
;; 
;; (document 'enter-chain
;;           '(("chain" chain))
;;           "Instantiates an 'eval' which evaluates expressions in 'chain'. The expression ':quit' will return to the previous eval. Uses the parameter 'eval-definer' for eval redefinition, this should be a function which can be used to redefine 'eval': it should set eval to it's input.")
;; 
;; (do 
;;   (enter-chain empty-chain)
;;   (def eval (fn [expr env] (list #t env)))
;;   :quit
;;   (should-be "enter-chain" #f #f))

;; TODO move else-where
(def simple-eval
 (fn [expr]
     (head (eval expr (get-current-env)))))

;; TODO: once you :quit, you can no longer :enter. Fix that
;; (def eval 
;;   (fn [expr env]
;;       (if (and (list? expr) (eq? (head expr) :enter-chain))
;;           (do
;;             (def mod-state 
;;               (over (.. (@ :env) (@ 'eval)) 
;;                     (fn [x] (add-quit (get-current-env) x))  
;;                     (lookup :state (simple-eval (nth 1 expr)))))
;;             (list :ok mod-state))
;;           (eval expr env))))

(def eval__ eval)
(def-rec eval 
  (fn [expr env]
      ;; The horror, the horror
      (if (list? expr) 
          (if (> (length expr) 0) 
              (if (eq? (head expr) :enter-chain)
                  (do
                     (def mod-state 
                       (over (.. (@ :env) (@ 'eval)) 
                             (fn [x] (add-quit (get-current-env) x)) 
                             (lookup :state (simple-eval (nth 1 expr)))))
                     (list :ok mod-state))
                  (eval__ expr env))
              (eval__ expr env))
          (eval__ expr env))))


;; enter-remote-chain

(def enter-remote-chain
  (fn [chain-id]
    (def old-eval eval)
    (def chain (update-chain-with empty-chain chain-id (fn [e] '()) (fn [e] '())))
    (print! (string-append "Synced with remote chain, at index: " (show (view (@ :index) chain))))
    (def ch (ref chain))
    (def inputs (ref (list)))
    (eval-definer
     (fn [e]
       (cond
        (eq? e :quit) (do (print! "Leaving remote-chain.")
                          (eval-definer old-eval))
        (eq? e :send) (do (print! "Sending inputs to remote chain.")
                          (map (fn [i] (send! chain-id i)) (reverse (read-ref inputs)))
                          (print! "Done! Leaving remote-chain.")
                          (eval-definer old-eval))
        :else (do (def x (eval-in-chain e (read-ref ch)))
                  (write-ref ch (view (@ :chain) x))
                  (modify-ref inputs (fn [is] (cons e is)))
                  (view (@ :result) x)))))))

(document 'enter-remote-chain
          '(("chain-id" string))
          "Syncs up to a remote chain, and allows experimentation inputs. There are two special inputs: ':quit' will leave the chain, ':send' will send all the accumulated inputs to the remote chain, one by one, and then leave the chain. Uses the parameter 'eval-definer' for eval redefinition, this should be a function which can be used to redefine 'eval': it should set eval to it's input.")

;; TODO - update docs.
;; TODO - eval as ref
;; TODO - get rid of eval-definer and stuff above
