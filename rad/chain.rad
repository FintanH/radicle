;; Chains: Functions for dealing with chains.

;; A chain is conceptually:
;;   - A known starting state (i.e. environment, and the assumption that `eval
;;     == base-eval')
;;   - A sequence of inputs.

(def empty-chain
  {:state (pure-env)
   :inputs (list)
   :index 0})

(def test-chain 
  (set (... (list (@ :state) (@ :env) (@ 'eval))) (fn [expr env] (list #t env)) empty-chain) )  

;; eval-in-chain

(def eval-in-chain
  (fn [expr chain]
    (def x (eval expr (lookup :state chain)))
    (dict :chain (dict :state (head (tail x))
                       :input (cons expr (lookup :logs chain))
                       :index (+ 1 (lookup :index chain)))
          :result (head x))))

(document 'eval-in-chain
          '(("expr" any) ("chain" chain))
          "Evaluates 'expr' in the 'chain' and returns a dict with the ':result' and the resulting ':chain'.")

(do 
  (def res (eval-in-chain '(+ 3 2) empty-chain))
  (def ~~> (fn [comp expected] (should-be "eval-in-chain" (view comp res) expected)))
  (~~> (@ :result) 5)
  (~~> (.. (@ :chain) (@ :input)) '((+ 3 2)))
  (~~> (.. (@ :chain) (@ :index)) 1))

;; update-chain-with

(def update-chain-with
  (fn [chain remote-chain-id cb-expr cb-res]
    (def new-inputs
      (receive! remote-chain-id (lookup :index chain)))
    (def upd-ch
      (fn [ch expr]
        (def x (eval-in-chain expr ch))
        (cb-expr expr)
        (cb-res (view (@ :result) x))
        (view (@ :chain) x)))
    (foldl upd-ch chain new-inputs)))

(document 'update-chain-with
          '(("chain" chain) ("chain-id" string) ("cb-expr" function) ("cb-res" function))
          "Updates 'chain' according to activity on the remote chain with ID 'chain-id', by pulling down and evaluating new inputs. Accepts two callbacks: 'cb-expr' is applied to the incoming expressions, and 'cb-res' is applied to the resulting values. Usually one uses 'print!' for both of these. If 'chain' is not a past version of the remote chain then the behaviour is unspecified.")

;; set-topmost-st

;; (def set-topmost-st
;;   (fn [new-state]
;;     (def once (fn [x y]
;;       (def first? (ref #t))
;;       (if (read-ref first?) x y))) 
;;     (def  
;;     (write-ref eval-ref 

;; add-quit

(def add-quit
  (fn [old-state new-eval]
    (fn [expr env]
      (if (eq? expr :quit)
          (list :ok old-state)
          (new-eval expr env)))))

;; enter-chain


;; (def test-chain 
;;   (set (.. (@ :state) (@ :env) (@ 'eval)) (fn [expr env] (list #t env)) empty-chain ))  


;; TODO move else-where
(def simple-eval
 (fn [expr]
     (head (eval expr (get-current-env)))))

;; store-exprs
(def store-exprs
 (fn [eref evalfn]
     (fn [expr env]
         (modify-ref cons eref)
         (evalfn expr env))))

;; add-send
(def add-send
  (fn [oeval remote-chain]
      (def expr-store (ref (list)))
      (if (eq? expr :send)
          (send! remote-chain (reverse (read-ref expr-store)))
          (store-exprs expr-store oeval ))))

;; enter-chain & enter-remote-chain

(def eval__ eval)
(def-rec eval 
  (fn [expr env]
      ;; The horror, the horror
      (if (list? expr) 
          (if (> (length expr) 0) 
              (cond  
                (eq? (head expr) :enter-chain) (do 
                                                 (def arg (simple-eval (nth 1 expr)))
                                                 (def mod-state 
                                                   (over (.. (@ :env) (@ 'eval)) 
                                                         (fn [x] (add-quit (get-current-env) x)) 
                                                         (lookup :state arg))) 
                                                 (list :ok mod-state)) 
                ;; Still broken
                (eq? (head expr) :enter-remote-chain) (do 
                                                        (def arg (simple-eval (nth 1 expr)))
                                                        (def mod-state 
                                                          (over (.. (@ :env) (@ 'eval)) 
                                                                (fn [x] (add-send (add-quit (get-current-env) x) arg)) 
                                                                (lookup :state arg))) 
                                                        (list :ok mod-state)) 
                :else (eval__ expr env))
              (eval__ expr env))
          (eval__ expr env))))

;; enter-remote-chain

(def enter-remote-chain
  (fn [chain-id]
    (def old-eval eval)
    (def chain (update-chain-with empty-chain chain-id (fn [e] '()) (fn [e] '())))
    (print! (string-append "Synced with remote chain, at index: " (show (view (@ :index) chain))))
    (def ch (ref chain))
    (def inputs (ref (list)))
    (eval-definer
     (fn [e]
       (cond
        (eq? e :quit) (do (print! "Leaving remote-chain.")
                          (eval-definer old-eval))
        (eq? e :send) (do (print! "Sending inputs to remote chain.")
                          (map (fn [i] (send! chain-id i)) (reverse (read-ref inputs)))
                          (print! "Done! Leaving remote-chain.")
                          (eval-definer old-eval))
        :else (do (def x (eval-in-chain e (read-ref ch)))
                  (write-ref ch (view (@ :chain) x))
                  (modify-ref inputs (fn [is] (cons e is)))
                  (view (@ :result) x)))))))

(document 'enter-remote-chain
          '(("chain-id" string))
          "Syncs up to a remote chain, and allows experimentation inputs. There are two special inputs: ':quit' will leave the chain, ':send' will send all the accumulated inputs to the remote chain, one by one, and then leave the chain. Uses the parameter 'eval-definer' for eval redefinition, this should be a function which can be used to redefine 'eval': it should set eval to it's input.")

;; TODO - update docs.
