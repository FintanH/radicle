(load! "rad/prelude/test.rad")
(load! "rad/prelude/basic.rad")
(load! "rad/prelude/patterns.rad")
(load! "rad/prelude/io.rad")
(load! "rad/prelude/bool.rad")
(load! "rad/prelude/recursion.rad")
(load! "rad/prelude/list.rad")
(load! "rad/prelude/dict.rad")
(load! "rad/prelude/set.rad")
(load! "rad/prelude/ref.rad")
(load! "rad/prelude/lens.rad")
(load! "rad/chain.rad")
(load! "rad/state-machine.rad")
(load! "rad/prelude/validation.rad")
(load! "rad/prelude/util.rad")

(def pure-prelude-files
  (list
   "rad/prelude/test.rad" ;; pure unless test env
   "rad/prelude/basic.rad"
   "rad/prelude/patterns.rad"
   "rad/prelude/pure-should-be.rad"
   "rad/prelude/recursion.rad"
   "rad/prelude/bool.rad"
   "rad/prelude/list.rad"
   "rad/prelude/dict.rad"
   "rad/prelude/set.rad"
   "rad/prelude/ref.rad"
   "rad/prelude/lens.rad"
   "rad/state-machine.rad"
   "rad/prelude/validation.rad"
   "rad/prelude/util.rad"
   ))

(document 'pure-prelude-files
          '()
          "List of files which together define the pure prelude.")

(def pure-prelude-code
  (read-many
    (apply string-append
           (map (fn [f] (read-file! f)) pure-prelude-files))))

(document 'pure-prelude-code
          '()
          "The pure prelude.")

(def send-prelude!
  (fn [chain-id]
    (send! chain-id pure-prelude-code)))

(document 'send-prelude!
          '(("chain-id" string))
"Send the pure prelude to a chain.")

(def _initial-prompt-text
  "Text used for greeting in the repl."
  "Welcome to radicle. Type (help) for help.")

(def help
  "Default help text."
  (fn []
    "radicle is a LISP-like language intended for programming chains, and interacting with those chains.

    Type (doc '<name>) for further documentation of <name>."))

(def f
  (fn [x]
    (match x
      ;; constants
      1                                 :number-one
      ;; predicates
      (/? keyword?)                     [:kw x]
      ;; guards
      ((/? number?) | (> x 42))         [:bigger-than-42 x]
      (/? number?)                      :non-1-number
      ;; more constants
      :hello                            :hello
      "hola"                            "que tal"
      ;; A custom pattern
      (/Just 'x)                        x
      :Nothing                          :Nothing
      ;; Some listy stuff
      (/cons 1 (/cons 2 'xs))           [:one-two xs]
      (/cons 1 (/cons _ (/cons 3 'xs))) [:one-something-three xs]
      (/cons 'x (/cons 'y 'xs))         [:non-singleton x y xs]
      (/cons 'x _)                      [:singleton x]
      /nil                              :empty-list
      ;; Pattern matching on dicts:
      (/keys {:a 'a :b 'b})             [:a-was a :b-was b]
      ;; Even the wildcard is user-defined!
      _                                 [:anything-else x])))
