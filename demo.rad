(load! "prompts.rad")

;; call (next) a few times..


(+ 1 1)

(* 2 2)

(def x 32)

(+ x x)

(def double (fn [x] (+ x x)))

(double 4)

(double 5)

"hello"

"world"

{:author "james"
 :msg "hello dnt!"}

;; how do we ensure messages are valid? e.g. well signed?

;; E.g. let's just say for now must be a string:

;; step 1 - the functionality
(def chat (ref []))

(def say
  (fn [msg]
      (modify-ref chat (fn [c] (cons msg c)))))

(def logs
  (fn []
      (put-str! (string/unlines (reverse (read-ref chat))))))

;; step 2 - *remove* unnecessary functionality

(def tx
  (fn [e _]
    (cond
      (string? e) (do (say e)
                      :ok)
      (eq? e :logs) (do (logs)
                        :ok)
      _ (throw 'any "Only strings!"))))

;; We could check for crypto signatures, but let's just do passwords here:

;; step 2
(def tx
  (fn [e _]
    (match e
           [:msg 's] :ok
           [:upd 'pw 'c]
           (if (eq? pw "secret")
             c
             (throw 'any "unauth")))))

;; Now we want to update the tx, after we have defined it!

;; step 3
[:upd "secret"
 (def admins ["pw1" "pw2"])]

[:upd "secret"
 (def tx
   (fn [e _]
     (match e
            [:msg 's] :ok
            [:upd 'pw 'c]
            (if (member? pw admins)
              c
              (throw 'any "unauth")))))]

[:upd "pw1" (thanks!)]
