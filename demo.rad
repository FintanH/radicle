(load! "rad/prelude.rad")

(def* msgs (ref []))

(defn say [u s]
  (add-right-ref msgs [u s])
  :ok)

(def tx
  (fn [e]
    (match e
           [:say 'u 's] (say u s)
           [:code 'c] c
           :default-query (read-ref msgs))))

(def* questions (ref {}))

(def* question (ref :no-question))

(def* voting (ref []))

(defn ask-question [q]
  (write-ref question q)
  (write-ref voting [])
  :ok)

(defn vote [user v]
  (add-right-ref voting [user v])
  :ok)

(defn get-result [vs]
  (sum (map (fn [v] (match v ['u 'tf] (if tf 1 -1)))
            vs)))

(defn close-voting []
  (let [vs (read-ref voting)
        q (read-ref question)
        r (get-result vs)]
    (write-ref voting [])
    (cond
      (eq? r 0) "Stalemate!"
      (> r 0) (insert-ref questions q #t)
      :else   (insert-ref questions q #f))))

(def tx
  (fn [e]
    (match e
           [:say 'u 's] (say u s)
           [:ask 'q] (ask-question q)
           [:vote 'u 'v] (vote u v)
           :close (close-voting)
           [:code 'c] c
           :default-query {:decisions (read-ref voting)
                           :chat (read-ref msgs)})))

;; oh no! people can vote more than once

(write-ref voting {})

(defn vote [u v]
  (insert-ref voting u v)
  :ok)

(defn get-result [vs]
  (sum (map (fn [v] (match v ['u 'tf] (if tf 1 -1)))
            (seq vs))))
